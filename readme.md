### Тестовое задание

Требуется разработать решение для вызова API стороннего сервиса.

1. Решение должно импортироваться другими частями системы и предоставлять для использования только публичный интерфейс, Fetcher.
2. Сам объект удовлетворяющий интерфейсу Fetcher должен инстанцироваться только в одном экземпляре, вне зависимости от места вызова конструктора … singletone.
3. Предполагается что функция которая создает объект удовлетворяющий интерфейсу(конструктор) Fetcher будет вызываться в сильно конкурентной среде, race condition.
4. Учитывая что Fetcher у нас singletone, то вызов методов интерфейса должен происходить параллельно, но ограничиваться максимальным количество одновременных запросов … например 2. worker pools, semaphore.

Интерфейс Fetcher
* Get() (string, error)
* List() ([]string, error)

Имплементация Fetcher просто возвращает какие то данные, не важно какие, но предполагается что это http запросы к стороннему сервису … в реализации можно сделать просто мок данных.

В итоге хочется увидеть сам модуль который мы будем импортировать и пример его использования в виде другого модуля … тесты приветствуются.

### Using:
```go get github.com/Yurovskikh/fetcher```

### Example:
    fetcher := fetcher.NewFetcher("http://localhost:8080", 5*time.Second)
    
    get, err := fetcher.Get()
    if err != nil {
    	log.Printf("failed to fetcher get: %s", err)
    }
    fmt.Println(get)
    
    list, err := fetcher.List()
    if err != nil {
    	log.Printf("failed to fetcher list: %s", err)
    }
    fmt.Println(list)
    
#### Оптимизация:
При создании инстанса fetcher не оптимально используются блокировки, при желании можно использовать ```sync.Once```
